#! /usr/bin/env python

# Copyright 2011, 2012, 2014 Martin C. Frith

# Read segments or alignments in various formats, and write them in
# SEG format.

import fileinput, itertools, operator, optparse, os, signal, sys

def printTab(*things):
    print "\t".join(map(str, things))

def importBed(lines):
    for line in lines:
        w = line.split()
        if not w: continue
        # Allow for "track" lines?
        # What about "#" for comments?
        chrom = w[0]
        beg = int(w[1])
        end = int(w[2])
        size = end - beg
        if len(w) > 5 and w[5] == "-": beg = -end  # it's on the minus strand
        printTab(size, chrom, beg)

def importChain(lines):
    for line in lines:
        w = line.split()
        if line.startswith("#"):
            continue
        elif line.startswith("chain"):
            tName, tSize, tStrand, tStart = w[2], int(w[3]), w[4], int(w[5])
            tPos = segStartFromMafStart(tStart, tStrand, tSize)
            qName, qSize, qStrand, qStart = w[7], int(w[8]), w[9], int(w[10])
            qPos = segStartFromMafStart(qStart, qStrand, qSize)
        elif w:
            size = int(w[0])
            printTab(size, tName, tPos, qName, qPos)
            if len(w) == 3:
                tPos += size + int(w[1])
                qPos += size + int(w[2])

def importGff(lines):
    for line in lines:
        w = line.split()  # XXX tabs?
        if not w: continue
        if w[0].startswith("#"): continue
        seqname = w[0]
        beg = int(w[3]) - 1  # convert from 1-based to 0-based coordinate
        end = int(w[4])
        strand = w[6]
        size = end - beg
        if strand == "-": beg = -end
        printTab(size, seqname, beg)

def segStartFromMafStart(mafStart, strand, seqLength):
    """MAF start coordinate --> SEG start coordinate."""
    if strand == "-": return mafStart - seqLength
    return mafStart

def isMafSequenceLine(line):
    return line.startswith("s")

def isGapless(column):
    return "-" not in column

def sequenceSpan(seq):  # in future, maybe allow for translated alignments
    return sum(i != "-" for i in seq)

def isTranslatedMaf(seq, size):
    return "\\" in seq or "/" in seq or sequenceSpan(seq) < size

# This only writes segment-tuples that align all the sequences.
# Should it write segment-tuples that align not all the sequences?
def importMaf(lines):
    for k, v in itertools.groupby(lines, str.isspace):
        sLines = filter(isMafSequenceLine, v)
        if not sLines: continue
        sRows = map(str.split, sLines)
        sCols = zip(*sRows)
        seqNames = sCols[1]
        starts = map(int, sCols[2])
        sizes = map(int, sCols[3])  # the alignment span in each sequence
        strands = sCols[4]
        seqLengths = map(int, sCols[5])
        alignmentRows = sCols[6]
        if True in map(isTranslatedMaf, alignmentRows, sizes):
            raise Exception("translated DNA is not supported")
        starts = map(segStartFromMafStart, starts, strands, seqLengths)
        alignmentCols = zip(*alignmentRows)
        # It would be more general to group by which sequences have gaps:
        for b, c in itertools.groupby(alignmentCols, isGapless):
            r = zip(*c)
            spans = map(sequenceSpan, r)
            if b:
                length = spans[0]
                printTab(length, *itertools.chain(*zip(seqNames, starts)))
            starts = map(operator.add, starts, spans)

def pslSplit(s):
    return s.rstrip(",").split(",")

def importPsl(lines):
    for line in lines:
        w = line.split()
        if not w: continue
        if not w[0].isdigit(): continue
        strand = w[8]
        # No support for translated alignments:
        if strand not in ("+", "-"):
            raise Exception("unrecognized strand: " + strand)
        qName = w[9]
        qSize = int(w[10])
        tName = w[13]
        blockSizes = pslSplit(w[18])
        qStarts = pslSplit(w[19])
        tStarts = pslSplit(w[20])
        for i, j, k in zip(blockSizes, tStarts, qStarts):
            qStart = segStartFromMafStart(int(k), strand, qSize)
            printTab(i, tName, j, qName, qStart)

def printPrimaryTranscript(chrom, name, strand, exonBegs, exonEnds):
    beg = exonBegs[0]
    end = exonEnds[-1]
    size = end - beg
    if strand == "+": pos = 0
    else:             pos = -size
    printTab(size, chrom, beg, name, pos)

def printIntrons(chrom, name, strand, exonBegs, exonEnds):
    if strand == "+": origin = exonBegs[0]
    else:             origin = exonEnds[-1]
    for i, j in zip(exonEnds[:-1], exonBegs[1:]):
        printTab(j - i, chrom, i, name, i - origin)

def printExons(chrom, name, strand, exonRanges, printBeg, printEnd):
    if strand == "+": pos = 0
    else:             pos = sum(b - e for b, e in exonRanges)  # negative
    for b, e in exonRanges:
        beg = max(b, printBeg)
        end = min(e, printEnd)
        if beg < end:
            printTab(end - beg, chrom, beg, name, pos + beg - b)
        pos += e - b

def getExons(chrom, name, strand, exonBegs, exonEnds, cdsBeg, cdsEnd, opts):
    if cdsBeg >= cdsEnd and (opts.utr5 or opts.utr3): return
    if strand == "+":
        isBegUtr = opts.utr5
        isEndUtr = opts.utr3
    else:
        isBegUtr = opts.utr3
        isEndUtr = opts.utr5
    minBeg = exonBegs[0]
    maxEnd = exonEnds[-1]
    exonRanges = zip(exonBegs, exonEnds)
    if opts.c:
        if isBegUtr and isEndUtr:
            printExons(chrom, name, strand, exonRanges, minBeg, maxEnd)
        elif isBegUtr:
            printExons(chrom, name, strand, exonRanges, minBeg, cdsEnd)
        elif isEndUtr:
            printExons(chrom, name, strand, exonRanges, cdsBeg, maxEnd)
        else:
            printExons(chrom, name, strand, exonRanges, cdsBeg, cdsEnd)
    else:
        if isBegUtr and isEndUtr:
            printExons(chrom, name, strand, exonRanges, minBeg, cdsBeg)
            printExons(chrom, name, strand, exonRanges, cdsEnd, maxEnd)
        elif isBegUtr:
            printExons(chrom, name, strand, exonRanges, minBeg, cdsBeg)
        elif isEndUtr:
            printExons(chrom, name, strand, exonRanges, cdsEnd, maxEnd)
        else:
            printExons(chrom, name, strand, exonRanges, minBeg, maxEnd)

def getGene(chrom, name, strand, exonBegs, exonEnds, cdsBeg, cdsEnd, opts):
    if opts.p:
        printPrimaryTranscript(chrom, name, strand, exonBegs, exonEnds)
    elif opts.i:
        printIntrons(chrom, name, strand, exonBegs, exonEnds)
    else:
        getExons(chrom, name, strand, exonBegs, exonEnds, cdsBeg, cdsEnd, opts)

def importGenePred(lines, opts):
    for line in lines:
        w = line.split()  # would it be better to split on tabs?
        if not w: continue
        if w[2] not in "+-": w.pop(0)  # allow for extra 1st column
        name = w[0]
        chrom = w[1]
        strand = w[2]
        cdsBeg = int(w[5])
        cdsEnd = int(w[6])
        exonBegs = map(int, pslSplit(w[8]))
        exonEnds = map(int, pslSplit(w[9]))
        getGene(chrom, name, strand, exonBegs, exonEnds, cdsBeg, cdsEnd, opts)

def gtfTranscriptId(attributesString):
    for i in attributesString.rstrip().rstrip(";").split("; "):
        t, v = i.split()
        if t == "transcript_id":
            return v.strip('"')
    raise Exception("missing transcript_id: " + attributesString)

def importGtf(lines, opts):
    records = []
    for line in lines:
        data = line.split("#")[0]
        w = data.split(None, 8)  # XXX tabs?
        if not w: continue
        chrom = w[0]
        feature = w[2]
        beg = int(w[3]) - 1  # convert from 1-based to 0-based coordinate
        end = int(w[4])
        strand = w[6]
        name = gtfTranscriptId(w[8])
        k = name, chrom, strand
        record = k, feature, beg, end
        records.append(record)
    records.sort()
    for k, v in itertools.groupby(records, operator.itemgetter(0)):
        name, chrom, strand = k
        v = list(v)
        exons = [i for i in v if i[1] == "exon"]
        exonBegs = [i[2] for i in exons]
        exonEnds = [i[3] for i in exons]
        cds = [i for i in v if i[1] in ("start_codon", "stop_codon")]
        if cds:
            cdsBeg = min(i[2] for i in cds)
            cdsEnd = max(i[3] for i in cds)
        else:
            cdsBeg = 0
            cdsEnd = 0
        getGene(chrom, name, strand, exonBegs, exonEnds, cdsBeg, cdsEnd, opts)

def cigarPieces(cigarString):
    for k, v in itertools.groupby(cigarString, str.isdigit):
        s = "".join(v)
        if k:
            n = int(s)
        else:
            if   s in "M=X": yield "M", n
            elif s in "DN":  yield "D", n
            elif s in "ISH": yield "I", n

def importSam(lines):
    for line in lines:
        if line.startswith("@"): continue
        w = line.split()  # XXX tabs?
        if not w: continue
        flag = int(w[1])
        if flag & 4: continue
        qname = w[0]
        rname = w[2]
        rpos = int(w[3]) - 1  # convert from 1-based to 0-based coordinate
        pieces = list(cigarPieces(w[5]))

        qlen = sum(j for i, j in pieces if i != "D")

        qpos = 0
        if flag & 16: qpos = -qlen  # it's a reverse-strand alignment

        for k, v in itertools.groupby(pieces, operator.itemgetter(0)):
            n = sum(j for i, j in v)
            if k == "M": printTab(n, rname, rpos, qname, qpos)
            if k != "I": rpos += n
            if k != "D": qpos += n

def segImport(opts, args):
    formatName = args[0].lower()
    lines = fileinput.input(args[1:])
    if   formatName == "bed": importBed(lines)
    elif formatName == "chain": importChain(lines)
    elif formatName == "genepred": importGenePred(lines, opts)
    elif formatName == "gff": importGff(lines)
    elif formatName == "gtf": importGtf(lines, opts)
    elif formatName == "maf": importMaf(lines)
    elif formatName == "psl": importPsl(lines)
    elif formatName == "sam": importSam(lines)
    else: raise Exception("unknown format: " + args[0])

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message

    usage = """
  %prog bed inputFile(s)
  %prog chain inputFile(s)
  %prog [options] genePred inputFile(s)
  %prog gff inputFile(s)
  %prog [options] gtf inputFile(s)
  %prog maf inputFile(s)
  %prog psl inputFile(s)
  %prog sam inputFile(s)"""

    description = "Read segments or alignments in various formats, and write them in SEG format."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-c", action="store_true",
                  help="get CDS (coding regions)")
    op.add_option("-5", action="store_true", dest="utr5",
                  help="get 5' untranslated regions (UTRs)")
    op.add_option("-3", action="store_true", dest="utr3",
                  help="get 3' untranslated regions (UTRs)")
    op.add_option("-i", action="store_true",
                  help="get introns")
    op.add_option("-p", action="store_true",
                  help="get primary transcripts (exons plus introns)")
    opts, args = op.parse_args()

    if opts.i and (opts.p or opts.c or opts.utr5 or opts.utr3):
        op.error("can't combine option -i or -p with any other option")
    if opts.p and (opts.i or opts.c or opts.utr5 or opts.utr3):
        op.error("can't combine option -i or -p with any other option")

    if len(args) < 1:
        op.error("please give me a format and some data")

    try: segImport(opts, args)
    except KeyboardInterrupt: pass  # avoid silly error message
    except Exception, e:
        prog = os.path.basename(sys.argv[0])
        sys.exit(prog + ": error: " + str(e))
