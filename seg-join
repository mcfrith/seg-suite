#! /usr/bin/env python

# Copyright 2011 Martin C. Frith

# Read two files of SEG data, and write their JOIN.

# Each input must be ordered in ASCII-betical order of column 2, then
# numeric order of column 3.

# SEG format looks like this:
# 78   seqA   594857   seqB   876
#
# The columns are: segment length, name of 1st sequence, start
# coordinate in 1st sequence, name of 2nd sequence, start coordinate
# in 2nd sequence.
#
# The number of sequences can be 1 or more.

# This algorithm does not care whether the coordinates are 0-based or
# 1-based.

# Internally, this algorithm replaces the length (1st column) with the
# end coordinate in the 1st sequence.

import itertools, operator, optparse, os, signal, sys

def myOpen(fileName):  # faster than fileinput
    if fileName == "-": return sys.stdin
    else:               return open(fileName)

def segBeg(s): return s[1], s[2]  # seqName, begCoordinate

def segEnd(s): return s[1], s[0]  # seqName, endCoordinate

def sortedSegInput(lines):
    oldSortKey = "", 0
    for line in lines:
        if line.startswith("#") or line.isspace(): continue
        s = line.split()
        # Should we skip lines where the first word is not a number?
        for i in range(0, len(s), 2):
            s[i] = int(s[i])
        s[0] += s[2]  # replace length with end
        newSortKey = segBeg(s)
        if newSortKey < oldSortKey:
            raise Exception("input not sorted properly")
        oldSortKey = newSortKey
        yield s

def writeTab(things): print "\t".join(map(str, things))

def segSliceTail(s, beg):
    offset = beg - s[2]
    for i in range(3, len(s), 2):
        yield s[i]
        yield s[i+1] + offset

def writeSegSlice(s, beg, end):
    writeTab(itertools.chain((end - beg, s[1], beg), segSliceTail(s, beg)))

def writeSegJoin(s, t, beg, end):
    writeTab(itertools.chain((end - beg, s[1], beg), segSliceTail(s, beg),
                             segSliceTail(t, beg)))

def isSame(things):
    """Are all the things the same?"""
    g = itertools.groupby(things)
    for i in g: break
    for i in g: return False
    return True

def isOverlappable(s, t):
    return s[3::2] == t[3::2] and isSame(map(operator.sub, s[2::2], t[2::2]))

def overlappingSegs(querySeg, referenceSegs, keptSegs, isAll):
    beg = segBeg(querySeg)
    end = segEnd(querySeg)
    if not keptSegs or segBeg(keptSegs[-1]) < end:
        for s in referenceSegs:
            keptSegs.append(s)
            if segBeg(s) >= end: break
    keptSegs[:] = [s for s in keptSegs if segEnd(s) > beg]
    for s in keptSegs:
        if segBeg(s) >= end: break
        if isAll and not isOverlappable(querySeg, s): continue
        yield s

def writeUnjoinableSegs(querySegs, referenceSegs, isComplete, isAll):
    keptSegs = []
    for i in querySegs:
        iend, iname, ibeg = i[:3]
        for j in overlappingSegs(i, referenceSegs, keptSegs, isAll):
            if isComplete: break
            jend, jname, jbeg = j[:3]
            if jbeg > ibeg: writeSegSlice(i, ibeg, jbeg)
            if jend > ibeg: ibeg = jend
        else:
            if iend > ibeg: writeSegSlice(i, ibeg, iend)

def writeJoinedSegs(sortedSegs1, sortedSegs2, isComplete1, isComplete2, isAll):
    keptSegs = []
    for i in sortedSegs1:
        iend, iname, ibeg = i[:3]
        for j in overlappingSegs(i, sortedSegs2, keptSegs, isAll):
            jend, jname, jbeg = j[:3]
            if isComplete1 and (ibeg < jbeg or iend > jend): continue
            if isComplete2 and (jbeg < ibeg or jend > iend): continue
            beg = max(ibeg, jbeg)
            end = min(iend, jend)
            if isAll: writeSegSlice(i, beg, end)
            else: writeSegJoin(i, j, beg, end)

def segJoin(opts, args):
    x = sortedSegInput(myOpen(args[0]))
    y = sortedSegInput(myOpen(args[1]))
    isComplete1 = 1 in opts.c
    isComplete2 = 2 in opts.c
    if   1 in opts.v: writeUnjoinableSegs(x, y, isComplete1, opts.w)
    elif 2 in opts.v: writeUnjoinableSegs(y, x, isComplete2, opts.w)
    else:             writeJoinedSegs(x, y, isComplete1, isComplete2, opts.w)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message

    usage = "%prog [options] file1.seg file2.seg"
    description = "Read two SEG files, and write their JOIN."
    epilog = "Report bugs to: seg-suite (ATmark) cbrc (dot) jp"
    op = optparse.OptionParser(usage=usage, description=description,
                               epilog=epilog)
    op.add_option("-c", type="int", action="append", default=[],
                  metavar="FILENUM",
                  help="only use complete/contained records of file FILENUM")
    op.add_option("-v", type="int", action="append", default=[],
                  metavar="FILENUM",
                  help="only write unjoinable parts of file FILENUM")
    op.add_option("-w", action="store_true",
                  help="join on whole segment-tuples, not just first segments")
    # Is "w" the best option letter?
    # "a" (all): unix join uses it for something else.
    # "i" (intersect): GNU join uses it for "ignore case".
    # "f" (full): "full join" has a different technical meaning in SQL.
    opts, args = op.parse_args()

    for i in opts.c:
        if i not in (1, 2):
            op.error("option -c: should be 1 or 2")

    for i in opts.v:
        if i not in (1, 2):
            op.error("option -v: should be 1 or 2")

    if 1 in opts.v and 2 in opts.v:
        op.error("option -v: cannot use both 1 and 2")

    if len(args) != 2:
        op.error("I need two file-names")

    if args[0] == "-" and args[1] == "-":
        op.error("cannot use '-' (standard input) for both files")

    try: segJoin(opts, args)
    except KeyboardInterrupt: pass  # avoid silly error message
    except Exception, e:
        prog = os.path.basename(sys.argv[0])
        sys.exit(prog + ": error: " + str(e))
