#! /usr/bin/env python

# Copyright 2011 Martin C. Frith

# Read two files of SEG data, and write their JOIN.

# Each input must be ordered in ASCII-betical order of column 2, then
# numeric order of column 3.

# SEG format looks like this:
# 78   seqA   594857   seqB   876
#
# The columns are: segment length, name of 1st sequence, start
# coordinate in 1st sequence, name of 2nd sequence, start coordinate
# in 2nd sequence.
#
# The number of sequences can be 1 or more.

# This algorithm does not care whether the coordinates are 0-based or
# 1-based.

# Internally, this algorithm replaces the length (1st column) with the
# end coordinate in the 1st sequence.

import fileinput, itertools, optparse, os, signal, sys

def segBeg(s): return s[1], s[2]  # seqName, begCoordinate

def segEnd(s): return s[1], s[0]  # seqName, endCoordinate

def sortedSegInput(lines):
    oldSortKey = "", 0
    for line in lines:
        if line.startswith("#") or line.isspace(): continue
        s = line.split()
        for i in range(0, len(s), 2):
            s[i] = int(s[i])
        s[0] += s[2]  # replace length with end
        newSortKey = segBeg(s)
        if newSortKey < oldSortKey:
            raise Exception("input not sorted properly")
        oldSortKey = newSortKey
        yield s

def writeTab(things): print "\t".join(map(str, things))

def segSliceTail(s, beg):
    offset = beg - s[2]
    for i in range(3, len(s), 2):
        yield s[i]
        yield s[i+1] + offset

def writeSegSlice(s, beg, end):
    writeTab(itertools.chain((end - beg, s[1], beg), segSliceTail(s, beg)))

def overlappingSegs(querySeg, referenceSegs, keptSegs):
    beg = segBeg(querySeg)
    end = segEnd(querySeg)
    if not keptSegs or segBeg(keptSegs[-1]) < end:
        for s in referenceSegs:
            keptSegs.append(s)
            if segBeg(s) >= end: break
    keptSegs[:] = [s for s in keptSegs if segEnd(s) > beg]
    for s in keptSegs:
        if segBeg(s) >= end: break
        yield s

def writeUnjoinableSegs(querySegs, referenceSegs, isComplete):
    keptSegs = []
    for i in querySegs:
        iPos = i[2]
        for j in overlappingSegs(i, referenceSegs, keptSegs):
            if isComplete: break
            if j[2] > iPos: writeSegSlice(i, iPos, j[2])
            if j[0] > iPos: iPos = j[0]
        else:
            if i[0] > iPos: writeSegSlice(i, iPos, i[0])

def writeJoinedSegs(sortedSegs1, sortedSegs2, isComplete1, isComplete2):
    keptSegs = []
    for i in sortedSegs1:
        for j in overlappingSegs(i, sortedSegs2, keptSegs):
            beg = max(i[2], j[2])
            end = min(i[0], j[0])
            if isComplete1 and (beg > i[2] or end < i[0]): continue
            if isComplete2 and (beg > j[2] or end < j[0]): continue
            writeTab(itertools.chain((end - beg, i[1], beg),
                                     segSliceTail(i, beg),
                                     segSliceTail(j, beg)))

def segJoin(opts, args):
    x = sortedSegInput(fileinput.input(args[0]))
    y = sortedSegInput(fileinput.input(args[1]))
    isComplete1 = 1 in opts.c
    isComplete2 = 2 in opts.c
    if   1 in opts.v: writeUnjoinableSegs(x, y, isComplete1)
    elif 2 in opts.v: writeUnjoinableSegs(y, x, isComplete2)
    else:             writeJoinedSegs(x, y, isComplete1, isComplete2)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message

    usage = "%prog [options] file1.seg file2.seg"
    description = "Read two SEG files, and write their JOIN."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-c", type="int", action="append", default=[],
                  metavar="FILENUM",
                  help="only use complete/contained records of file FILENUM")
    op.add_option("-v", type="int", action="append", default=[],
                  metavar="FILENUM",
                  help="only write unjoinable parts of file FILENUM")
    opts, args = op.parse_args()

    for i in opts.c:
        if i not in (1, 2):
            op.error("option -c: should be 1 or 2")

    for i in opts.v:
        if i not in (1, 2):
            op.error("option -v: should be 1 or 2")

    if 1 in opts.v and 2 in opts.v:
        op.error("option -v: cannot use both 1 and 2")

    if len(args) != 2:
        op.error("I need two file-names")

    if args[0] == "-" and args[1] == "-":
        op.error("cannot use '-' (standard input) for both files")

    try: segJoin(opts, args)
    except KeyboardInterrupt: pass  # avoid silly error message
    except Exception, e:
        prog = os.path.basename(sys.argv[0])
        sys.exit(prog + ": error: " + str(e))
